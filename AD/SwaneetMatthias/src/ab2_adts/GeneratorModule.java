package ab2_adts;

/**
 * 
 * @author Swaneet Sahoo, Matthias Nitsche
 */
public class GeneratorModule {

	public static void main(String[] args) {
		GeneratorModule gm = new GeneratorModule(20, 20, 0.8);
		gm.generateRandomMatrix();
		// System.out.println(gm.getMatrix());
		// System.out.println(gm.getRatio());
	}

	private double notZeroProbability;
	private Matrix matrix;
	private double MAX_VAL = 2000.0;
	private double MIN_VAL = -2000.0;
	private int m;
	private int n;

	/**
	 * Randomly populate a m x n Matrix with a given Probability. A higher
	 * Probability means less zeros within the Matrix.
	 * 
	 * @param m
	 *            m dimension of a Matrix
	 * @param n
	 *            n dimension of a Matrix
	 * @param notZeroProbability
	 *            the higher this percentage (from 0 to 1) less zeros are in
	 *            the Matrix.
	 */
	public GeneratorModule(int m, int n, double notZeroProbability) {
		this.notZeroProbability = notZeroProbability;
		this.m = m;
		this.n = n;
		generateRandomMatrix();
	}

	/**
	 * Returns the last Matrix generated by generateRandomMatrix().
	 * 
	 * @return Current Matrix.
	 */
	public Matrix getMatrix() {
		return this.matrix;
	}

	/**
	 * Generates a Matrix and populates it with random Elements.
	 * 
	 */
	public void generateRandomMatrix() {
		matrix = new MatrixArray(m, n);
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				matrix.insert(i, j, getRdmDouble());
			}
		}
	}

	/**
	 * Count the zeros.
	 * 
	 * @return Integer that represents the current Number of the zeros within
	 *         the current Matrix.
	 */
	public int countZero() {
		int count = 0;
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				if (Double.compare(matrix.get(i, j), 0.0) == 0) {
					count += 1;
				}
			}
		}
		return count;
	}

	/**
	 * Ratio between the current zeros in the Matrix and elements that are
	 * higher than 0.
	 * 
	 * @return Double that represents the ratio between zero count and m*n
	 *         Elements.
	 */
	public double getRatio() {
		return ((double) countZero()) / ((double) (m * n));
	}

	private double getRdmDouble() {
		double acc = 0;
		if (Math.random() < this.notZeroProbability) {
			if (Math.random() < 0.5)
				acc = Math.random() * MAX_VAL;
			else
				acc = Math.random() * MIN_VAL;
		} else {
			acc = 0.0;
		}
		return acc;
	}

}
